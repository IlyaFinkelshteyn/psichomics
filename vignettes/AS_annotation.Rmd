---
title: "Splicing event annotation"
author: "Nuno Agostinho"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: yes
vignette: >
  %\VignetteIndexEntry{Splicing event annotation}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

The splicing events annotation is different according to the program that
creates it. The programs which allow to quantify expression levels of
alternative splicing events studied in this report are:

* [MISO](https://miso.readthedocs.org/en/fastmiso/)
* [SUPPA](https://bitbucket.org/regulatorygenomicsupf/suppa)
* [VAST-TOOLS](https://github.com/vastgroup/vast-tools)
* [MATS](http://rnaseq-mats.sourceforge.net)

It's also important to understand that the splicing events annotation may vary
according to the splicing event type. The most common splicing event types
annotated across the aforementioned programs are described in the following
image (retrieved from the
[SUPPA website](https://bitbucket.org/regulatorygenomicsupf/suppa)).

![Splicing event types](https://bitbucket.org/repo/4gEBMd/images/2185438774-Slide1.jpg)

To conciliate the output from the different programs, it was decided to parse
each splicing event ID to a R data type known as list with all the important
attributes of an event, including:

* Species
* Chromosome
* Strand
* Gene
* mRNA
* Splicing event type
* Inclusion level (PSI)

In order to store the events themselves, it's possible to characterise all the
represented splicing event types by using the boundaries of the following 4
exons:

* Upstream constitutive exon (C1)
* Upstram alternative exon (A1)
* Downstream alternative exon (A2)
* Downstream constitutive exon (C2)

The following table describes which positions should be stored to identify each
splicing event type:

Splicing event type        | C1 start | C1 end | A1 start | A1 end | A2 start | A2 end | C2 start | C2 end |
-------------------------- | :------: | :----: | :------: | :----: | :------: | :----: | :------: | :----: |
Exon skipping              |          | •      | •        | •      |          |        | •        |        |
Mutually exclusive exons   |          | •      | •        | •      | •        | •      | •        |        |
Alternative 5' splice site |          | • •    |          |        |          |        | •        |        |
Alternative 3' splice site |          | •      |          |        |          |        | • •      |        |
Retained intron            | •        | •      |          |        |          |        | •        | •      |
Alternative first exon     | •        | •      | •        | •      |          |        | •        |        |
Alternative last exon      |          | •      | •        | •      |          |        | •        | •      | 
Tandem UTR                 |          |        |          |        |          |        | •        | • •    | 

Note there are two glyphs in some cases. That means two alternative positions
are stored (for example, in the case of the alternative 5' splice site, the C1
end can alternatively be one of the two positions).

Before discussing how to parse thousands and thousands of events, we should
reflect a bit on the tools available to compare different solutions that solve
the same problem and how to measure performance on R. You can read about it
in the article [Measuring performance](Measuring performance.Rmd).

Another thing to consider is whether we should be using a list or an object to
store the information pertaining to each event. I'll try to create a list at
first but maybe it would be better to have a class for events. This way, the
attributes would be much clearer to others. But really, would it be that
different if we take into account that the documentation explains the data
structure anyway? And is there any impact in the performance of the same script
using objects instead of lists?

> TODO: event data structure - list VS object

# Retrieving alternative splicing annotation
To get the most complete annotation of alternative splicing events, we'll
combine the alternative splicing annotation from many programs like MISO,
VAST-TOOLS, SUPPA and MATS. Others programs' annotation may be added later on.

## MISO
It's really easy to get the alternative splicing annotation used by
MISO since it's available online at
<https://miso.readthedocs.org/en/fastmiso/annotation.html> (GFF3 format)

MISO's annotation files include skipped exon (SE), mutually exclusive exon
(MXE), intron retention (RI), alternative 3' and 5' splice site (A3SS and A5SS),
alternative first and last exon (AFE and ALE) and tandem UTR. Each event type
is contained in a file with the respective acronym shown in parenthesis.

Here follows an example of an AS annotation file used in MISO:
    
chr1 | SE | gene | 16854 | 18061 | . | - | . | ID=chr1:7778:7924:-\@chr1:7096:7605:-\@chr1:6717:6918:-;Name=chr1:7778:7924:-\@chr1:7096:7605:-\@chr1:6717:6918:-;gid=chr1:7778:7924:-\@chr1:7096:7605:-\@chr1:6717:6918:-
chr1 | SE | mRNA | 16854 | 18061 | . | - | . | ID=chr1:7778:7924:-\@chr1:7096:7605:-\@chr1:6717:6918:-.A;Parent=chr1:7778:7924:-\@chr1:7096:7605:-\@chr1:6717:6918:-;gid=chr1:7778:7924:-\@chr1:7096:7605:-\@chr1:6717:6918:-
chr1 | SE | exon | 16854 | 17055 | . | - | . | ID=chr1:7778:7924:-\@chr1:7096:7605:-\@chr1:6717:6918:-.A.dn;Parent=chr1:7778:7924:-\@chr1:7096:7605:-\@chr1:6717:6918:-.A;gid=chr1:7778:7924:-\@chr1:7096:7605:-\@chr1:6717:6918:-

To generate a list of events from MISO's annotation file, we'll use:
```{r, eval=FALSE}
miso.hg19 <- lapply(c("AFE", "ALE", "SE", "MXE", "A5SS", "A3SS", "RI", "TandemUTR"),
                    function(x) {
                        type <- paste0("/genedata/Resources/Annotations/MISO/hg19/", x, ".hg19.gff3")
                        print(type)
                        read.delim(type, header=F, comment.char="#")
                    }
)
library(plyr)
miso.hg19 <- rbind.fill(miso.hg19)
misoEvents <- parseMultipleMisoEvents(miso.hg19, progress = T)
```

Let's check the numbers. And let's not forget that there are unrecognized events
(i.e. badly-formatted events) in these numbers as well.
```{r, eval=FALSE}
number <- function(annotation, type)
  sum(sapply(annotation, "[[", "Event type") == type)

length(misoEvents)              # all event types:    108340
number(misoEvents, "SE")        # skipped exons:       39222
number(misoEvents, "AFE")       # alt. first exons:    19720
number(misoEvents, "ALE")       # alt. last exons:     10269
number(misoEvents, "MXE")       # mutually exclusive:   2722
number(misoEvents, "A5SS")      # alt. 5 splice site:  12807
number(misoEvents, "A3SS")      # alt. 3 splice site:  14957
number(misoEvents, "RI")        # intron retention:     5987
number(misoEvents, "TandemUTR") # tandem UTR:           2656
```

## SUPPA
We need to run the SUPPA's command generateEvents to get the alternative 
splicing annotation from a GTF file, like this:
 
```
python suppa.py generateEvents -i $GTF -o suppaEvents -e SE SS MX RI FL
```

This command generates many annotation files (ending with the `ioe` extension
and one for each event type supported), which include the alternative event
coordinates. These files look like the following:

seqname	| gene_id |	event_id |	alternative_transcripts |	total_transcripts
------- | ------- | -------- | ------------------------ | -----------------
HSCHR1_1_CTG31 | ENSG00000262826 | ENSG00000262826;RI:HSCHR1_1_CTG31:153762047:153762147-153762346:153762418:+ | ENST00000576422,ENST00000571829 | ENST00000576422,ENST00000571829,ENST00000576030,ENST00000571768,ENST00000575952,ENST00000575774,ENST00000575708,ENST00000573844
HG1350_HG959_PATCH | ENSG00000272985 | ENSG00000272985;RI:HG1350_HG959_PATCH:42384895:42385080-42385440:42385558:+ | ENST00000609291 | ENST00000609291,ENST00000609866
HG1350_HG959_PATCH | ENSG00000272985 | ENSG00000272985;RI:HG1350_HG959_PATCH:42384895:42385194-42385440:42385558:+ | ENST00000609291 | ENST00000609291,ENST00000608019

The AS event types supported by SUPPA are skipped exon (SE), mutually exclusive 
exon (MX), intron retention (RI), alternative 3' and 5' splice site (A3 and A5) 
and alternative first and last exon (AF and AL).

Let's generate a list of events from the SUPPA annotated events.
```{r, eval=FALSE}
read_path <- function(path, item, ...)
    read.delim(sprintf(path, item), ...)

suppa.path <- "/genedata/NunoA/psi_output/suppa_%s.tab.psi"
suppa.hg19 <- lapply(c("A3", "A5", "AF", "AL", "MX", "RI", "SE"), 
                     function(type) read_path(suppa.path, type, row.names=NULL))
suppa.hg19 <- rbind.fill(suppa.hg19)[[1]] # discard inclusion levels
suppaEvents <- parseSuppaEventID(suppa.hg19)

number <- function(annotation, type)
  sum(sapply(annotation, "[[", "Event type") == type)

length(suppaEvents)               # all event types:    179108
number(suppaEvents, "SE")         # skipped exons:       40419
number(suppaEvents, "AFE")        # alt. first exons:    75548
number(suppaEvents, "ALE")        # alt. last exons:     18741
number(suppaEvents, "MXE")        # mutually exclusive:   5114
number(suppaEvents, "A5SS")       # alt. 5 splice site:  15651
number(suppaEvents, "A3SS")       # alt. 3 splice site:  16861
number(suppaEvents, "RI")         # intron retention:     6774
number(suppaEvents, "TandemUTR")  # tandem UTR:              0
```

## MATS
After running MATS with two samples (two FASTQ or BAM files) and a GTF file
annotation of transcripts, the program returns a folder named *ASEvents* that
contains all alternative splicing events derived from the GTF file alone in
simple TXT files that are tab-delimited.

The AS event types supported by MATS are skipped exon (SE), mutually exclusive 
exon (MXE), intron retention (RI), alternative 3' and 5' splice site (A3SS and 
A5SS) and alternative first and last exon (AFE and ALE). MATS also creates files
of each event type's novel events.

The files look like this:

GeneID | geneSymbol | chr | strand | exonStart_0base | exonEnd | upstreamES | upstreamEE | downstreamES | downstreamEE
-------|------------|-----|--------|-----------------|---------|------------|------------|--------------|-------------
"ENSG00000146263" | "MMS22L" | chr6 | - | 97717982 | 97718159 | 97717777 | 97717868 | 97720579 | 97720757
"ENSG00000146263" | "MMS22L" | chr6 | - | 97681736 | 97681856 | 97678144 | 97679528 | 97694503 | 97694566
"ENSG00000146263" | "MMS22L" | chr6 | - | 97711210 | 97711324 | 97702432 | 97702609 | 97715747 | 97715878

Generating a list of events from the annotation is easy:
```{r, eval=FALSE}
read_path <- function(path, item, ...)
    read.delim(sprintf(path, item), ...)

mats.path <- "/genedata/NunoA/psi_calculation/mats_out/ASEvents/fromGTF.%s.txt"
types <- c("A3SS", "A5SS", "AFE", "ALE", "MXE", "RI", "SE")
mats.hg19 <- lapply(c(types, paste0("novelEvents.", types)), 
                     function(type) read_path(mats.path, type, row.names=NULL))

matsEvents <- lapply(1:length(mats.hg19),
                     function(i) {
                         type <- rep(types, 2)[i]
                         print(type)
                         annotation <- mats.hg19[[i]]
                         if (nrow(annotation) > 0)
                            return(parseMultipleMatsEvents(annotation, type))
                         else
                             return(NULL)
                     })

matsEvents <- matsEvents[!sapply(matsEvents, is.null)]
j <- list()
for(i in matsEvents)
    j <- c(j, i)
matsEvents <- j

number <- function(annotation, type)
  sum(sapply(annotation, "[[", "Event type") == type)

length(matsEvents)               # all event types:    118417
number(matsEvents, "SE")         # skipped exons:       37935
number(matsEvents, "AFE")        # alt. first exons:    51062
number(matsEvents, "ALE")        # alt. last exons:      8951
number(matsEvents, "MXE")        # mutually exclusive:   2333
number(matsEvents, "A5SS")       # alt. 5 splice site:   4890
number(matsEvents, "A3SS")       # alt. 3 splice site:   7706
number(matsEvents, "RI")         # intron retention:     5540
number(matsEvents, "TandemUTR")  # tandem UTR:              0
```

## VAST-TOOLS
VAST-TOOLS annotation comes as an extra download packed in VASTDB. They are
located in the folder named *Templates*. Each AS event type supported has its
own file with the exception of some cases where there are two files presenting 
an alternative annotation for the same event type.

GENE | EVENT | COORD | LENGTH | FullCO | COMPLEX
-----|-------|-------|--------|--------|--------
TSPAN6 | ENSG00000000003_CASSETTE1 | chrX:99885756-99885863 | 108 | chrX:99887482,99885756-99885863,99884983          | S
TSPAN6 | ENSG00000000003_CASSETTE2 | chrX:99888402-99888536 | 135 | chrX:99888928,99888402-99888536,99887565          | S
TSPAN6 | ENSG00000000003_CASSETTE3 | chrX:99891188-99891204 | 17  | chrX:99891605+99891790,99891188-99891204,99890743 | S

The event types covered by VAST-TOOLS are exon skipping (EXSK for single AS
exons, MULTI for multi AS exons and MIC for microexons), intron retention (IR)
and alternative 3' and 5' splice site (ALT3 and ALT5). There are other
VAST-TOOLS files:

- **MERGE3m** files merge all exon skipping events (those from EXSK, MULTI and MIC)
- **COMBI** files are used for the *a posteriori* pipeline; it uses all exon-exon
junctions and calls AS events based on read maps to exon-exon junctions
- **FULL** is used to decide what to print

Now, let's just generate a list of events from the annotation files. Just don't 
forget that annotation files don't have inclusion levels and the like. As the
document with more columns is RI event's annotation file with 7 columns while
all the others have 6 columns, parsed events won't show inclusion levels if they
have 7 or less columns (since there isn't data with that info... duh).

```{r, eval=FALSE}
read_path <- function(path, item1, item2, ...)
    read.delim(sprintf(path, item1, item2), ...)

vastTools.path <- "/genedata/Resources/Software/vast-tools/VASTDB/Hsa/TEMPLATES/Hsa.%s.Template%s.txt"
types <- c("ALT3", "ALT5", "COMBI", "IR", "MERGE3m", "MIC", "EXSK", "MULTI")
num <- c(rep("", 6), rep(".2", 2))
vastTools.hg19 <- lapply(1:length(types), 
                         function(i) read_path(vastTools.path, types[i], num[i], row.names=NULL))

vastToolsEvents <- lapply(vastTools.hg19, parseMultipleVastToolsEvents, progress = TRUE)

number <- function(annotation, type)
  sum(sapply(annotation, "[[", "Event type") == type)

length(vastToolsEvents)               # all event types:    
number(vastToolsEvents, "SE")         # skipped exons:       
number(vastToolsEvents, "AFE")        # alt. first exons:    
number(vastToolsEvents, "ALE")        # alt. last exons:      
number(vastToolsEvents, "MXE")        # mutually exclusive:   
number(vastToolsEvents, "A5SS")       # alt. 5 splice site:   
number(vastToolsEvents, "A3SS")       # alt. 3 splice site:   
number(vastToolsEvents, "RI")         # intron retention:     
number(vastToolsEvents, "TandemUTR")  # tandem UTR:              0
```

# Parsing alternative splicing annotation
The annotation originated from different programs was parsed. You can read more
about it in the following articles:

* [MISO](Parsing MISO events.Rmd)
* [SUPPA](Parsing SUPPA events.Rmd)
* [VAST-TOOLS](Parsing VAST-TOOLS events.Rmd)
* [MATS](Parsing MATS events.Rmd)