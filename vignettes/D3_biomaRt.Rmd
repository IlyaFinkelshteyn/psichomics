---
title: "Using biomaRt"
author: "Nuno Agostinho"
date: "3 June 2016"
output: 
  html_document: 
    toc: yes
---

Let's check available BioMart databases and select one dataset.

```{r marts, eval=FALSE}
library("biomaRt")
listMarts()
ensembl <- useMart("ENSEMBL_MART_ENSEMBL")

# List head of datasets available
knitr::kable(listDatasets(ensembl))

# Select dataset
ensembl <- useDataset("hsapiens_gene_ensembl", mart=ensembl)
```

A query to a specific database needs filters (query restrictions; e.g., only
retrieve genes from chrosome X) and attributes (values of interest to retrieve).

```{r, eval=FALSE}
# List available filters
knitr::kable(listFilters(ensembl))

# List available filters
knitr::kable(listAttributes(ensembl))

# Query dataset
getBM(attributes=c('ensembl_gene_id', "external_gene_name", "description", "start_position", "end_position"),
      filters="external_gene_name", values="RAC1", mart=ensembl)
```

> TODO: Allow to use local BioMart databases (see reference)

## Using the Ensembl REST API
```{r, eval=FALSE}
url <- "http://rest.ensembl.org/overlap/region/human/7:140424943-140624564"
resp <- httr::GET(url, query = list(feature = "gene", feature="cds", 
                                    feature="exon"))
r <- content(resp, "text", encoding = "UTF8")
json <- jsonlite::fromJSON(r)

# For the GRCH37 assembly, use http://grch37.rest.ensembl.org
url <- "http://grch37.rest.ensembl.org/overlap/region/human/7:97717983-97718159"
resp <- httr::GET(url, query = list(feature = "gene"))
r <- content(resp, "text", encoding = "UTF8")
json <- jsonlite::fromJSON(r)
```

# Retrieving the gene names of the annotation
```{r, eval=FALSE}
annot  <- readRDS("data/hg19_splicingAnnotation.RDS")
type   <- annot$SE
chr    <- type$Chromosome
start  <- numeric(nrow(type))
end    <- numeric(nrow(type))
strand <- type$Strand == "+"

start <- ifelse(strand, annot$SE$A1.start, annot$SE$A1.end)
end   <- ifelse(!strand, annot$SE$A1.start, annot$SE$A1.end)

# For the GRCH37 assembly, use http://grch37.rest.ensembl.org
url <- "http://grch37.rest.ensembl.org/overlap/region/human/%s:%s-%s"
url <- sprintf(url, chr, start, end)

## TOO SLOW!
max <- 10
pb <- txtProgressBar(min = 1, max = max, style = 3)
genes <- lapply(seq_along(url[1:max]), function(each) {
    setTxtProgressBar(pb, each)
    resp <- httr::GET(url[each], query = list(feature = "gene"))
    r <- content(resp, "text", encoding = "UTF8")
    json <- jsonlite::fromJSON(r)
    return(json$external_name)
})

## WRONG GENE SYMBOLS...?
url <- sprintf("%s:%s:%s", chr, start, end)
ensembl = useMart(biomart="ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org", 
                  path="/biomart/martservice", dataset="hsapiens_gene_ensembl")
results <- getBM(attributes = c("external_gene_name", "chromosome_name", 
                                "start_position","end_position"),
                 filters = c("chromosomal_region"),
                 values=url[1:500],
                 mart=mart)

## Faster with a text with the matches
# From Table Browser, go to "hg19" > "Genes" > "UCSC genes" > "knownGene"
# As the output format, use "select fields from primary and related tables"
# Select "chrom", "cdsStart", "cdsEnd" and "geneSymbol" and hit to get output
# Remove the weird chromosomes and also the "chr" part from the chromosome name
geneSymbol <- read.delim("~/Downloads/ucsc_gene_symbol.txt")
names(geneSymbol) <- c("chrom", "start", "end", "geneSymbol")

df <- data.frame(chr, start, end, stringsAsFactors = F)

library("progress")
max <- nrow(df)
pb <- progress_bar$new(
    format = "  downloading [:bar] :percent in :elapsed (wait for :eta)",
    total = max)
# Now simply check if an event is inside a gene... let's hope this is easy!
gene <- lapply(seq(max), function(i) {
    pb$tick()
    i <- df[i, ]
    symbol <- subset(geneSymbol, chrom==i$chr & start <= i$start & end >= i$end)
    return(symbol$geneSymbol)
})
```

It will be faster with a text file containing gene names and respective
coordinates. To get this file, go to Table Browser, select the Human genome
(hg19), "Genes" > "UCSC genes" > "knownGene". Use "select fields from primary 
and related tables" as the output format. Select the fields "chrom", "cdsStart",
"cdsEnd" and "geneSymbol" and get the output. Don't forget to remove weird
chromosomes and also the "chr" part from the chromosome identifier.

```{r, eval=FALSE}
## Faster with a text file containt gene names and coordinates
# From Table Browser, go to "hg19" > "Genes" > "UCSC genes" > "knownGene"
# As the output format, use "select fields from primary and related tables"
# Select "chrom", "cdsStart", "cdsEnd" and "geneSymbol" and hit to get output
# Remove the weird chromosomes and also the "chr" part from the chromosome name
geneSymbol <- read.delim("~/Downloads/ucsc_gene_symbol.txt")
names(geneSymbol) <- c("chrom", "strand", "start", "end", "geneSymbol")

# Convert reference gene annotation to GRanges
info <- GRanges(seqnames = geneSymbol$chrom, symbol = geneSymbol$geneSymbol,
                strand = geneSymbol$strand,
                ranges = IRanges(start = geneSymbol$start, end = geneSymbol$end))
info <- unique(info)
    
## Alternative splicing annotation
annot <- readRDS("data/hg19_splicingAnnotation.RDS")
for (each in names(annot)) {
    print(each)
    type   <- annot[[each]]
    chr    <- type$Chromosome
    strand <- type$Strand
    
    pos <- switch(each,
                  "A3SS"=c("C1.end", "C2.start"),
                  "A5SS"=c("A1.end", "C2.start"),
                  "ALE" =c("A1.start", "C2.start"),
                  "AFE" =c("C1.end", "A1.end"),
                  "SE"  =c("A1.start", "A1.end"),
                  "MXE" =c("C1.end", "C2.start"),
                  "RI"  =c("C1.start", "C2.end"),
                  "TandemUTR"=c("C1.start", "C1.end"))
    
    pos1 <- annot[[each]][[pos[1]]]
    pos2 <- annot[[each]][[pos[2]]]
    
    start <- ifelse(pos1 > pos2, pos2, pos1)
    end   <- ifelse(pos1 < pos2, pos2, pos1)
    df <- data.frame(seqnames=chr, strand, start, end)
    
    # Convert alternative splicing annotation to GRanges
    annotRanges <- GRanges(seqnames = chr, strand = strand,
                           ranges = IRanges(start = start, end = end))
    
    # Merge overlaps between the gene and alternative splicing annotation
    merge <- mergeByOverlaps(annotRanges, info)
    merge <- data.frame(merge$annotRanges, merge$symbol)
    merge <- unique(merge)
    
    # Let's ignore the ones that are duplicated because of more than one gene name
    # TODO: don't ignore more than one gene name...
    merge <- merge[!duplicated(merge[ , -6]), ]
    
    # Join overlaps so it's easy to add to the original data frame
    library(plyr)
    library(dplyr)
    join <- full_join(df, merge)
    annot[[each]][["Gene"]] <- join$merge.symbol
}
```

## Older database versions

## Proxy issues
When having proxy problems, try one (or both) of the following commands:

* `Sys.putenv("http\_proxy" = "http://my.proxy.org:9999")`
* `options(RCurlOptions = list(proxy="uscache.kcc.com:80", proxyuserpwd="user:pwd")`

## References
- [The biomaRt user's guide](https://bioconductor.org/packages/release/bioc/vignettes/biomaRt/inst/doc/biomaRt.pdf)
- https://bioconductor.org/packages/devel/bioc/vignettes/SGSeq/inst/doc/SGSeq.html