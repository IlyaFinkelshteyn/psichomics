---
title: "Measuring performance"
author: "Nuno Agostinho"
date: "`r Sys.Date()`"
output: html_document
vignette: >
  %\VignetteIndexEntry{Measuring performance}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Let's discuss a bit the tools we have to compare different solutions that solve
the same problem and how to measure performance on R.

## Rprof
There are many ways to measure the performance of a chunk of code in R. `Rprof`
comes already built-in. To use it, you simply need to something like:

```{r}
x <- c(2,3)
Rprof()
## Code to be profiled
mean(x)

Rprof(NULL)
## Code NOT to be profiled
mean2 <- function(x) sum(x)/length(x)

Rprof(append = TRUE)
## Code to be profiled
mean2(x)

Rprof(NULL)

# Produce a summary of the usage information
summaryRprof()
```

The output is a bit enigmatic but fortunately for us there are other tools that
are easier to use.

## profVis
This one is pretty great: it visually shows the time spent in each line of code
in your program so you know which lines are responsible for slowing you down.
Just run it like this:

```{r eval=F}
library(profvis)
profvis(
  # complex function you'd like to profile
)
```

## microbenchmark
To compare times between chunks of code, we can use `microbenchmark`. It uses
the most accurate timing functions from the operating system and ensures minimal
overhead. Use the `time` argument to modify the number of times an expression is
evaluated and the `unit` argument to choose the time unit: ns, us, ms, s, t, hz,
khz, mhz, eps or f.

```{r}
x <- c(2,3)

library(microbenchmark)
res <- microbenchmark(
  times = 100, # number of times to repeat
  unit = "ms", # unit of time to be displayed
  mean(x),
  sum(x)/length(x)
)

# Print results
print(res)

# Results in boxplot
boxplot(res)

# Results in ggplot2 (prettier)
library("ggplot2")
autoplot(res)
```

See how faster it is to use `sum(x)/length(x)` over `mean(x)`? Yeah, R functions
aren't that well optimised, unfortunately.

## rbenchmark
Although it also allows to compare times between chunks of code, `rbenchmark` 
can be more useful than `microbenchmark` to check the elapsed time of a program 
over multiple iterations since it shows the real elapsed time. Note however that 
this method is less precise than `microbenchmark` and has higher overhead. You
can modify the `replications` argument to alter the number of times an 
expression is evaluated.

```{r}
x <- c(2,3)

library(rbenchmark)
benchmark(
  replications = 100, # number of times to repeat
  mean(x),
  sum(x)/length(x)
)
```

# Some comparisons

This section is dedicated to the comparison of functions of interest.

## Comparing apply functions

> TODO: compare apply, by, eapply, lapply, mapply, rapply, tapply, vapply

```{r apply}
l <- list(a = 1:10, b = 11:20)
expect <- c(Min.=0, "1st Qu."=0, Median=0, "3rd Qu."=0, Max.=0)

res <- microbenchmark(
    lapply = lapply(l, fivenum),
    sapply = sapply(l, fivenum),
    vapply = vapply(l, fivenum, expect))
autoplot(res)
```

```{r}
l <- list(a = as.character(1:10), b = as.character(11:20))
res <- microbenchmark(
    lapply1=lapply(l, "[[", 1), 
    sapply1=sapply(l, "[[", 1),
    vapply1=vapply(l, "[[", 1, FUN.VALUE = character(1)),
    lapply2=lapply(l, function(x) x[[1]]), 
    sapply2=sapply(l, function(x) x[[1]]),
    vapply2=vapply(l, function(x) x[[1]], character(1)))
autoplot(res)
```

## Comparing comparison methods

```{r comparison}
validator <- c("gene", "mRNA", rep("exon", 3), "mRNA", rep("exon", 2))
event <- factor(validator)
res <- microbenchmark(
  a=all(event == validator),
  b=all(as.character(event) == validator),
  c=identical(as.character(event), validator),
  d=all.equal(as.character(event), validator),
  e=all(as.character(event) == as.character(validator)),
  f=identical(as.character(event), as.character(validator)),
  g=all.equal(as.character(event), as.character(validator))
)
autoplot(res)
```

## Faster subsetting
```{r}
set.seed(1)  # for reproducible example
df <- data.frame(age=sample(1:65, 1e6, replace=TRUE), x=rnorm(1e6), y=rpois(1e6,25))

library(data.table)
dt <- as.data.table(df)

library(microbenchmark)
res <- microbenchmark(times=10,
    df[which(df$age>5),],
    subset(df, age>5), 
    df[df$age>5,],
    dt[age > 5])
autoplot(res)
```

However, we can't use data table instead of data frame without modifying the
source code. To get a column from a data table, we need to either get it by its
name like ```dt[ , V3]``` or by its index with an added argument 
```dt[ , 3, with=FALSE]```.