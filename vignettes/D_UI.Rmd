---
title: "User Interface"
author: "Nuno Agostinho"
date: "28 January 2016"
output: 
html_document: 
toc: yes
---

# Conditional panels VS renderUI
It seems that renderUI has a problem that conditionalPanel do not: when trying
to reload the same code, renderUI reloads everything, not loading any previous
state from the user. On the other hand, conditionalPanel does save and restores
the objects state when reloading the same section. The only drawback to
conditionalPanel is that it the condition must be a JavaScript expression while
renderUI is all in R. Another solution would be to use both! :)

# Running the Shiny interface
Simple run the command `shiny::runApp()`.

# Saving and loading the state of a session
For a similar effort, check https://github.com/jcheng5/shiny-resume

The `session` object seems to be the one holding all the information of a Shiny
session. Besides, it even includes the variables `input` (`session$input`) and
`output` (`session$output`) which hold the information of every element in the
app.

An idea would then be to save and load this `session` variable whenever there's
a change by the user. You could also use `session$onSessionEnded` to save only
when the session ends (how would this behave in case of reload?).

Detecting a change by the user is easy. Simply create a global variable (let's
call it `savedSession`) and observe all input changes in the `server`:
```{r, eval = F}
observe({
    # Observe all available input changes
    lapply(names(input),
           function(each) {
               observeEvent(input[[each]], {
                   # What to do when a change is detected?
                   savedSession <- session
                   saveRDS(savedSession file = "~/Documents")
               })
           })
})
```

Now here's the tricky part: how to restore a previous session? One way could be
to save the object after any change and load it afterwards using the functions
`saveRDS` and `readRDS`. But using `readRDS` in the beginning of the server
function does nothing... Either because the UI part is loaded first or they are
independent. So either way, I need to load the `session` object in the UI itself
and not in session or find a way to modify the `session` directly.

Well, there's a way to at least load all input values directly. Since some (if
not all) Shiny update* functions seem to be wrappers around
`session$sendInputMessage`, we could try using that function directly:

```{r, eval = FALSE}
# Instead of using
# updateSelectInput(session, input_id, selected = "hist")
session$sendInputMessage(input_id, value = "hist")
```

If the command is the same for most (if for all) input types, then we only need
to iterate by all input values and changed them to the ones we want. Will this
work in a complex app? We'll see...

Basically, we only need to run this command to load all the saved results (let's
say we have a button `load` that loads the input values when desired):
```{r, eval = FALSE}
observeEvent(input$load, {
    input <- readRDS(file = "~/Dropbox/session.RDS")
    lapply(names(input),
           function(each) {
               # print(paste(each, input[[each]]))
               value <- list(value = input[[each]])
               session$sendInputMessage(each, value)
           })
})
```

It seems that there is some issue when using fileInput that doesn't allow to
load all the input values for some reason. The fastest way to fix this is to not
use fileInput.

# Packages of interest

## shinyFiles
File input is slow because it copies the files to a temporary folder. The
package `shinyFiles` removes this step which is better when using a local app.

## shinyRGL
Shiny wrapper for RGL (WebGL) in R

## sparkline
Sparkline allows to make plots in tables (does it support datatables?)

## htmlwidgets
"Easy" way to port JavaScript packages to R/Shiny.

# Internationalisation
There aren't many reasons to translate this package to other languages. English
is the most used language in the scientific community, after all. More about
this topic is available at
https://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Internationalization

# Passing messages
A simple way to pass messages to any kind of interface would be to allow to
choose the function that passes messages. For example, when in the interactive
shell, the function could be the print function. While in a Shiny app, the
function would show the message in a more appropriate fashion. This would be
useful to show the progress of some functions of interest (read: slow).

# How to make Shiny update an object in real-time?
There's a problem in Shiny: if you pile up a bunch of instructions in an
observer, the output will only be shown when every single calculation ends. This
means we can't change the UI in the same observer where we're crunching big data
or else the user will only see the progress when the calculation ends... For
example, imagine you have a message showing asking to replace the data. The user
clicks "replace data" so the message should go away and the data should laod.
The problem is the message only goes away AFTER the data loads... which sucks.

What has been already tried? I already tried to put the lengthy expression in
another observer waiting to see when the button is pressed (doesn't work) and
tried to create a boolean variable so the lengthy expression would only begin
when that variable changed to TRUE (nope, it didn't work).

To see how could I resolve this, I remembered that Shiny add a progress bar. Of
course, the progress bar progresses while the calculation is going, so maybe I
could try to use the same mechanism the progress bar uses to update its UI.
Unfortunately, I can't: the progress bar uses a special stack only made to store
the progress bar values. Isn't that cheating or something? Oh, well, now what?

Actually, shinyjs seems to execute the actions immediately. When asked to
disable the "GO" button so people can't change the input while the data is being
loaded, it has no problems doing it. How is that possible? Let's check the code!

```{r}
shinyjs::disable
shinyjs:::jsFuncHelper
```

Seems we can do it by sending a custom JavaScript message. Besides, shinyjs also
has some wrapper functions to allow us to run JavaScript functions. Nice.

# Automatically changing inputs

There's an easy way to automatically change Shiny inputs: just use `shinyjs`
and you can even do it in R code! Unfortunately, this isn't that great if you
want to create thousands of JavaScript events... The case in question involved
creating a datatable where each element in the first column has a link to
another graph showing that element in detail. Easy enough to do with a subset of
the data.

First of all, we style the row names as links. This is important to distribute
unique IDs to each element of the row name (since in R, data frames' row names
MUST be unique, we know all IDs will be unique if we use the row name as the
ID). Note that we replace spaces for underscores or else this wouldn't work.

```{r, eval=FALSE}
createLink <- function(val) {
    html <- paste('<a id="%s" title="Get more information about this event"',
                  'href="#" >%s</a>')
    link <- sprintf(html, gsub("_", " ", val), val)
    return(link)
}
```

Next, we'll resort to `shinyjs` to create a `onclick` event for each element in
the row names. This event will change the value of other inputs, allowing us
to change the current view of the program.

```{r, eval=FALSE}
observe({
    lapply(gsub(" ", "_", rownames(mtcars)), function(i) {
        onclick(i, {
            # Update plot presented
            updateSelectizeInput(session, "selectizePlot",
                                 selected = "plot4")
            # Update event highlighted
            updateSelectizeInput(session, "selectizeEvent",
                                 selected = gsub("_", " ", i))
        })
    })
})
```

All's good while using the standard data frame `mtcars`. However, when using a
larger data farme with 15000 rows, the data takes eternities to show and the
interface lags a lot. Instead, we'll just use JavaScript to accomplish the same
thing by editing the earlier `createLink` function:

```{r, eval=FALSE}
createLink <- function(val) {
    onclick <- sprintf('document.getElementById(\'%s\').selectize.setValue(\'%s\')',
                       c("selectizePlot", "selectizeEvent"),
                       c("plot4", "Valiant"))
    onclick <- paste(onclick, collapse = "; ")
    html <- paste('<a id="%s" title="Get more information about this event"',
                  'href="#" onclick="%s">%s</a>')
    link <- sprintf(html, gsub("_", " ", val), onclick, val)
    return(link)
}
```

A job well done, gentlemen!

# Downloading files

Currently, the files are downloaded using the function `download.file`.
Unfortunately, R becomes unresponsive while using it and the Shiny app will
crash if this takes too long... There are at least 2 solutions for this:

* Delegate the browser to download the files and wait for the files to be
completed
* Use an extra core to download the data; this would be easy if Windows
supported forking; since it doesn't, the only other solution would be starting
the app with 2 cores, one for the interface and the other for calculations

# Naming the IDs

You should be careful when naming IDs. They shouldn't be spaced according to
[HTML 4.01 specification](http://www.w3.org/TR/html401/types.html#type-name),
even though it's possible to use spaces (but you'll have trouble to use CSS
selectors, afterwards). If you want to use input IDs in JavaScript expressions
(which is useful when using a `conditionalPanel`), it's better to use
`input[id='some.id.goes.here']` to allow to retrieve IDs with dots. The standard
`input.some_id_goes_here` doesn't allow to retrieve IDs with dots.

# Font Awesome
We are able to easily use the FontAwesome pack for glyphs. It's free and has a
lot of glyphs! Besides, it has a few extra options as well. :)

# Storing files in local storage
It's probably faster if we store the slowest files to load already processed in
a RData file. Thus, we just need to load the already RData file instead! Also, 
since the RData files are binary, they don't need as much space as text files.

# Validating forms
A cool thing we could have is a form validator: whenever the user writes on the
form, it would have an indication whether it's writing something that it should
or it shouldn't do. Such a thing is possible with JavaScript and a cool library
is Bootstrap Validator. To use a JavaScript library like this, we simply need
to download the JavaScript library, move the ".js" file to the `inst` folder,
use the `shiny::includeScript` function to use it and add the attributes they
ask to the input fields. Done!... almost. For some reason, it's not working in
the current application. Why is that?

# Using JavaScript to check the state of the checkboxes
There's a problem with running JavaScript: the value returned is not immediate.
I was using the following code to save the value of the checkboxes in the data
table to the variable `input$removeGroups`:

```{r, eval=FALSE}
observeEvent(input[[id("removeGroups")]], {
    session$sendCustomMessage(type = "getCheckedBoxes", "removeGroups")
    
    # Get groups for the data table that is visible and active
    active <- input[[id("dataTypeTab")]]
    groups <- getGroupsFrom(active)
    
    # Remove selected rows
    selected <- as.numeric(input$removeGroups)
    setGroupsFrom(active, groups[-selected, , drop=FALSE])
})
```

This doesn't work. After checking some checkboxes, when pressing the remove
button it would do nothing (1). Pressing again, it removed the selected row (2).
Pressing once again with no checkbox selected, it would remove another row (3).
What's happening? Well, when printing the value of `input$removeGroups`, it was
obvious that the value was NULL for the step (1), the rows selected for step (2)
and the same rows for step (3). So the value wasn't updated immediately, what
now? I created an `observer` where we would wait for `input$removeGroups` to
change from NULL. But now it's deleting row after row (e.g. selecting row 2
would delete rows 2, 3, 4, etc. one at a time since all those rows become row 2
after the previous row 2 is deleted). How stupid (of me)!

Well, I figured, we only need to set input$removeGroups to NULL. Yeah... it
seems Shiny doesn't allow us to do that.

```
Warning: Error in $<-.reactivevalues: Attempted to assign value to a read-only
reactivevalues object
```

No direct modification in R means we can only modify that variable using...
JavaScript! So we could maybe modify the variable to a neutral state (a state
where we know the variable is not ready yet) after removing the selected rows.
Since this solution has the same delay we were trying to solve in the beginning, 
this simply means we still delete the same index when sequentially clicking the
"remove selected groups" button.

Another thing tried was to use a flag instead. When changing `input$removeGroups`,
set flag to TRUE so the observer knows the input has changed and after removing
the rows, set flag to FALSE and wait for it to be TRUE again. This presents the
same problem, since the flag is set to TRUE before the input is ready, so the
actual solution is a combination of using the flag and change the value of the
variable to a state we know it's neutral.

Therefore, to only remove the rows desired, we wait for `input$removeGroups` to 
be ready and change a flag to TRUE; when it's ready, we change it the value to 0 
(neutral state so it doesn't continually remove rows), set flag to FALSE so it
only runs once per each click in the "remove selected groups" button and remove
the rows. It works as intended! :)

# Representing the groups interface
There's a simple way to make this better. We could simply represent contextual
Venn diagrams (i.e. when hovering over a group, it would show information about
that group). Or maybe use a package like `UpSetR` to allow to show much more
groups than simply 5 (up to 9?) groups. Also, check `d3vennr` which allows
interactive Venn diagrams using d3.js. It even tells how to add contextual 
tooltips at http://www.buildingwidgets.com/blog/2015/6/5/week-22-d3vennr