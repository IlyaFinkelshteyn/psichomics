---
title: "User Interface"
author: "Nuno Agostinho"
date: "28 January 2016"
output: 
  html_document: 
    toc: yes
---

# Conditional panels VS renderUI
It seems that renderUI has a problem that conditionalPanel do not: when trying
to reload the same code, renderUI reloads everything, not loading any previous
state from the user. On the other hand, conditionalPanel does save and restores
the objects state when reloading the same section. The only drawback to
conditionalPanel is that it the condition must be a JavaScript expression while
renderUI is all in R. Another solution would be to use both! :)

# Running the Shiny interface
Simple run the command `shiny::runApp()`.

# Saving and loading the state of a session
For a similar effort, check https://github.com/jcheng5/shiny-resume

The `session` object seems to be the one holding all the information of a Shiny
session. Besides, it even includes the variables `input` (`session$input`) and
`output` (`session$output`) which hold the information of every element in the
app.

An idea would then be to save and load this `session` variable whenever there's
a change by the user. You could also use `session$onSessionEnded` to save only
when the session ends (how would this behave in case of reload?).

Detecting a change by the user is easy. Simply create a global variable (let's
call it `savedSession`) and observe all input changes in the `server`:
```{r, eval = F}
observe({
    # Observe all available input changes
    lapply(names(input),
           function(each) {
               observeEvent(input[[each]], {
                   # What to do when a change is detected?
                   savedSession <- session
                   saveRDS(savedSession file = "~/Documents")
               })
           })
})
```

Now here's the tricky part: how to restore a previous session? One way could be
to save the object after any change and load it afterwards using the functions
`saveRDS` and `readRDS`. But using `readRDS` in the beginning of the server
function does nothing... Either because the UI part is loaded first or they are
independent. So either way, I need to load the `session` object in the UI itself
and not in session or find a way to modify the `session` directly.

Well, there's a way to at least load all input values directly. Since some (if
not all) Shiny update* functions seem to be wrappers around
`session$sendInputMessage`, we could try using that function directly:

```{r, eval = FALSE}
# Instead of using
# updateSelectInput(session, input_id, selected = "hist")
session$sendInputMessage(input_id, value = "hist")
```

If the command is the same for most (if for all) input types, then we only need
to iterate by all input values and changed them to the ones we want. Will this
work in a complex app? We'll see...

Basically, we only need to run this command to load all the saved results (let's
say we have a button `load` that loads the input values when desired):
```{r, eval = FALSE}
observeEvent(input$load, {
    input <- readRDS(file = "~/Dropbox/session.RDS")
    lapply(names(input),
           function(each) {
             # print(paste(each, input[[each]]))
             value <- list(value = input[[each]])
             session$sendInputMessage(each, value)
           })
  })
```

It seems that there is some issue when using fileInput that doesn't allow to
load all the input values for some reason. The fastest way to fix this is to not
use fileInput.

# Packages of interest

## shinyFiles
File input is slow because it copies the files to a temporary folder. The
package `shinyFiles` removes this step which is better when using a local app.

## shinyRGL
Shiny wrapper for RGL (WebGL) in R

## sparkline
Sparkline allows to make plots in tables (does it support datatables?)

## htmlwidgets
"Easy" way to port JavaScript packages to R/Shiny.

# Internationalisation
There aren't many reasons to translate this package to other languages. English
is the most used language in the scientific community, after all. More about
this topic is available at
https://cran.rstudio.com/doc/manuals/r-devel/R-exts.html#Internationalization

# Passing messages
A simple way to pass messages to any kind of interface would be to allow to
choose the function that passes messages. For example, when in the interactive
shell, the function could be the print function. While in a Shiny app, the
function would show the message in a more appropriate fashion. This would be
useful to show the progress of some functions of interest (read: slow).

# How to make Shiny update an object in real-time?
There's a problem in Shiny: if you pile up a bunch of instructions in an
observer, the output will only be shown when every single calculation ends. This
means we can't change the UI in the same observer where we're crunching big data
or else the user will only see the progress when the calculation ends... For
example, imagine you have a message showing asking to replace the data. The user
clicks "replace data" so the message should go away and the data should laod.
The problem is the message only goes away AFTER the data loads... which sucks.

What has been already tried? I already tried to put the lengthy expression in
another observer waiting to see when the button is pressed (doesn't work) and
tried to create a boolean variable so the lengthy expression would only begin
when that variable changed to TRUE (nope, it didn't work).

To see how could I resolve this, I remembered that Shiny add a progress bar. Of
course, the progress bar progresses while the calculation is going, so maybe I
could try to use the same mechanism the progress bar uses to update its UI.
Unfortunately, I can't: the progress bar uses a special stack only made to store
the progress bar values. Isn't that cheating or something? Oh, well, now what?

Actually, shinyjs seems to execute the actions immediately. When asked to
disable the "GO" button so people can't change the input while the data is being
loaded, it has no problems doing it. How is that possible? Let's check the code!

```{r}
shinyjs::disable
shinyjs:::jsFuncHelper
```

Seems we can do it by sending a custom JavaScript message. Besides, shinyjs also
has some wrapper functions to allow us to run JavaScript functions. Nice.

# Automatically changing inputs

There's an easy way to automatically change Shiny inputs: just use `shinyjs`
and you can even do it in R code! Unfortunately, this isn't that great if you
want to create thousands of JavaScript events... The case in question involved
creating a datatable where each element in the first column has a link to
another graph showing that element in detail. Easy enough to do with a subset of
the data.

First of all, we style the row names as links. This is important to distribute
unique IDs to each element of the row name (since in R, data frames' row names
MUST be unique, we know all IDs will be unique if we use the row name as the
ID). Note that we replace spaces for underscores or else this wouldn't work.

```{r, eval=FALSE}
createLink <- function(val) {
    html <- paste('<a id="%s" title="Get more information about this event"',
                  'href="#" >%s</a>')
    link <- sprintf(html, gsub("_", " ", val), val)
    return(link)
}
```

Next, we'll resort to `shinyjs` to create a `onclick` event for each element in
the row names. This event will change the value of other inputs, allowing us
to change the current view of the program.

```{r, eval=FALSE}
observe({
    lapply(gsub(" ", "_", rownames(mtcars)), function(i) {
        onclick(i, {
            # Update plot presented
            updateSelectizeInput(session, "selectizePlot",
                                 selected = "plot4")
            # Update event highlighted
            updateSelectizeInput(session, "selectizeEvent",
                                 selected = gsub("_", " ", i))
        })
    })
})
```

All's good while using the standard data frame `mtcars`. However, when using a
larger data farme with 15000 rows, the data takes eternities to show and the
interface lags a lot. Instead, we'll just use JavaScript to accomplish the same
thing by editing the earlier `createLink` function:

```{r, eval=FALSE}
createLink <- function(val) {
    onclick <- sprintf('document.getElementById(\'%s\').selectize.setValue(\'%s\')',
                      c("selectizePlot", "selectizeEvent"),
                      c("plot4", "Valiant"))
    onclick <- paste(onclick, collapse = "; ")
    html <- paste('<a id="%s" title="Get more information about this event"',
                  'href="#" onclick="%s">%s</a>')
    link <- sprintf(html, gsub("_", " ", val), onclick, val)
    return(link)
}
```

A job well done, gentlemen!

# Downloading files

Currently, the files are downloaded using the function `download.file`.
Unfortunately, R becomes unresponsive while using it and the Shiny app will
crash if this takes too long... There are at least 2 solutions for this:

* Delegate the browser to download the files and wait for the files to be
completed
* Use an extra core to download the data; this would be easy if Windows
supported forking; since it doesn't, the only other solution would be starting
the app with 2 cores, one for the interface and the other for calculations

# Naming the IDs

You should be careful when naming IDs. They shouldn't be spaced according to
[HTML 4.01 specification](http://www.w3.org/TR/html401/types.html#type-name),
even though it's possible to use spaces (but you'll have trouble to use CSS
selectors, afterwards). If you want to use input IDs in JavaScript expressions
(which is useful when using a `conditionalPanel`), it's better to use
`input[id='some.id.goes.here']` to allow to retrieve IDs with dots. The standard
`input.some_id_goes_here` doesn't allow to retrieve IDs with dots.

# Font Awesome
We are able to easily use the FontAwesome pack for glyphs.