---
title: "Survival analysis"
output: html_document
---

Survival analysis allows to analyse the expected duration of time until one or
more events (such as death) happen. This analysis can be used to estimate the
rate of survival and whether different conditions (e.g. a disease treatment) can
modify the probability of survival.

R has the basic tools to perform survival analysis. The following lines of code
allow us to draw a Keplen-Meier plot to visualise the extended use of
chemioterapy vs regular in patients with Acute Myelogenous Leukemia.
```{r survival}
library(survival)
leukemiaSurv <- survfit(Surv(time, status) ~ x, data = aml)
plot(leukemiaSurv, col = c("red", "purple"))
legend(90, .9, c("Extended", "Control"), lty = 1, col = c("red", "purple"))
```

## Kaplan-Meier method
Also known as product limit, this method estimates the proportion of a
population who would survive a given length of time under the same circumstances
given a set of observed survival times.

### Example using TCGA clinical data
TCGA offers clinical data that can be used in a survival analysis. The type of
data available includes "patient", "drug", "follow_up" and "radiation". If we
want to get clinical data's time for/since an event, we'll need to use multiple
rows with the same apparent information but with slighlty different names. We'll
just use the max of those numbers for any given column (they are usually the
same numbers across columns, but not all rows have the information, using NAs
instead).

```{r tcga-survival, eval=FALSE}
# Get clinical data
clinical <- data.frame(t(read.delim(paste0(
    "/genedata/home/nuno/Downloads/gdac.broadinstitute.org_ACC.Merge_Clinical.",
    "Level_1.2015110100.0.0/ACC.clin.merged.txt"), header=FALSE, row.names=1)))
rownames(clinical) <- toupper(clinical$patient.bcr_patient_barcode)

# Get specific columns and get the max number of days recorded for each sample
sampleDays <- function(col, clin) {
    cols <- grep(col, names(clin))
    row <- apply(clin[cols], 1, function(i)
        if(!all(is.na(i))) max(as.numeric(i), na.rm = TRUE) else NA)
    return(row)
}

# Save the days from columns of interest in a data frame
cols <- c("days_to_death", "days_to_last_followup")
colsDays <- setNames(lapply(cols, sampleDays, clinical), cols)
colsDays <- as.data.frame(colsDays)

# Create new time using the days to death replacing the NAs with days to last 
# follow up
colsDays$time <- ifelse(!is.na(colsDays[[1]]), colsDays[[1]], colsDays[[2]])

# Indicate event of interest (in this case, if the subject dies) and groups
colsDays$event <- ifelse(!is.na(colsDays[[1]]), 1, 0)
colsDays$groups <- c("A", "B")

# Estimate and plot survival curves by groups
form <- Surv(time, event) ~ groups
surv <- survfit(form, data = colsDays)
plot(surv, lty = 2:3)

# Estimate and plot survival curves as one
form <- Surv(time, event) ~ 1
surv <- survfit(form, data = colsDays)
plot(surv)
```

## Data censoring and truncation

When a patient has no death date but there is a last follow up date that means
we know nothing more about the patient since that day and it cannot be used in
a Kaplan-Meier plot anymore.

- **Left censoring:** the event of interest has already occurred before subject
enrolment (rare)
- **Right censoring:** subject leaves a study or the study ends after a fixed
time (e.g. study time of 5 years) before the event occurs (type I right 
censoring) or study ends when a fixed number of events occurs amongst the
subjects (type II right censoring)
- **Left truncation:** subjects has been at risk before entering the study
- **Right truncation:** entire study population already experienced the event
(e.g. historical survey of select cancer patients)

Censoring the data is easy:
```{r censoring, eval=FALSE}
# No censoring
form <- Surv(time, event) ~ groups
surv <- survfit(form, data = colsDays)
plot(surv, lty = 1, col = "blue")

# Left censoring
formLeft <- Surv(time, event, type = "left") ~ groups
survLeft <- survfit(formLeft, data = colsDays)
lines(survLeft, lty = 4, col = "orange")

# Right censoring (notice this is over the not censored lines)
formRight <- Surv(time, event, type = "right") ~ groups
survRight <- survfit(formRight, data = colsDays)
lines(survRight, lty = 2, col = "red")
```

## Types of survival curves
"Some studies may use a combination of different types of survival curves to
express their data. The main difference between the curves is what is defined as
the event or end-point. In **overall survival curves**, the event of interest is 
death from any cause. This provides a very broad, general sense of the mortality
of the groups. In **disease free survival curves**, the event of interest is 
relapse of a disease rather than death. Because patients may have relapsed but 
not yet died, disease free survival curves are lower than overall survival 
curves. **Progression free survival** uses progression of a disease as an 
end-point (i.e. tumor growth or spread). This is useful in isolating and
assessing the effects of a particular treatment on a disease. **Disease specific
survival curves** (also known as cause specific survival) utilize death from the 
disease of interest as the endpoint. This curve can be misleading in that it 
will always be higher than overall survival and disease free survival curves
because events are limited only to death from a specific disease, i.e. patients 
that have disease relapse or die from non- related causes are not included as 
events. In addition, death caused by disease related factors (i.e. treatments) 
may not be included in disease-specific survival curves."

From: http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3932959/pdf/nihms549224.pdf

## Cox model
A cox model allows to explore the relationship between the survival of a patient
and several explanatory variables by isolating the effects of treatment from the
effects of other variables. It also allows us to estimate the risk of death 
(i.e. hazard) for an individual, given their prognostic variables.

A positive regression coefficient for an explanatory variable means that the 
hazard is higher, and thus the prognosis worse. Conversely, a negative 
regression coefficient implies a better prognosis for patients with higher
values of that variable.

```{r}
# Fit a Cox proportional hazards model and plot the survival for a 60-year old 
fit <- coxph(Surv(futime, fustat) ~ age, data=ovarian) 
plot(survfit(fit, newdata=data.frame(age=60)), 
     xscale=365.25, xlab="Years", ylab="Survival")
```

## Cumulative hazard

```{r, eval=FALSE}
# Cumulative hazard using the Fleming-Harrington method
lsurv2 <- survfit(Surv(time, status) ~ x, aml, type='fleming')
plot(lsurv2, lty=2:3, fun="cumhaz", xlab="Months", ylab="Cumulative Hazard")
```

## Plotting libraries

### ggplot2 and ggfortify
http://rpubs.com/sinhrks/plot_surv

### Plotly
https://plot.ly/ipython-notebooks/survival-analysis-r-vs-python/

### Highcharts

To plot a Keplen-Meier using Highcharts, we'll simulate the following plot:
```{r, eval=FALSE}
aml.surv <- survfit(Surv(time, status) ~ x, data = aml)
plot(aml.surv, mark.time = TRUE)
```

To do it, we'll use the information from the `aml.surv` object as follows.
```{r, eval=FALSE}
library(highcharter)
# The X axis will be the time and the Y axis the survival probability
# These variables don't separate by groups, so we'll have to split them
x <- aml.surv$time
y <- aml.surv$surv

# Check which points should be marked
mark <- ifelse(aml.surv$n.censor, 1, 0)
marker <- list(list(fillColor="black", symbol=fa_icon_mark("plus"), 
                    enabled=TRUE))
dont <- list(list(enabled=FALSE))

# Check groups
group <- aml.surv$strata

data <- list.parse3(data.frame(x, y, mark, group=rep(names(group), group), 
                               stringsAsFactors = FALSE))
data <- lapply(data, function(i) c(i, marker = ifelse(i$mark, marker, dont)))

hc <- highchart() %>%
    hc_tooltip(shared = TRUE) %>%
    hc_chart(zoomType="xy") %>%
    hc_yAxis(min=0, max=1)

for (name in names(group)) {
    ls <- lapply(data, function(i) if (i$group == name) i)
    ls <- Filter(Negate(is.null), ls)
    
    first <- NULL
    if (!0 %in% vapply(ls, "[[", "x", FUN.VALUE = numeric(1))) {
        # Add first value if there is no x = 0 in the data
        first <- list(list(x=0, y=1, marker=dont))
    }
    
    hc <- hc %>% hc_add_series(data=c(first, ls), step="left", name=name)
}
hc
```

Another important thing are the data manipulation tools available in
`survival:::plot.survfit`, as it's easy to understand from this snippet of code:
```{r, eval=FALSE}
if (!missing(fun)) {
    if (is.character(fun)) {
        tfun <- switch(fun, 
                       log = function(x) x, 
                       event = function(x) 1 - x, 
                       cumhaz = function(x) -log(x),
                       cloglog = function(x) log(-log(x)), 
                       pct = function(x) x * 100,
                       logpct = function(x) 100 * x, 
                       identity = function(x) x,
                       stop("Unrecognized function argument"))
    }
    else if (is.function(fun)) 
        tfun <- fun
    else stop("Invalid 'fun' argument")
    ssurv <- tfun(ssurv)
    if (!is.null(supper)) {
        supper <- tfun(supper)
        slower <- tfun(slower)
    }
    firsty <- tfun(firsty)
}
```

It may be important to use the cumulative hazard function (`cumhaz`) and since
I'm including that one, I might as well include the others with a slight 
adaptation of this code (and of course an attribution to the reference function
too).

Let's also see if this is ready for using with `coxph` results.
```{r, eval=FALSE}
plotSurvCurves <- function(surv, fun = NULL, ymin=0, ymax=1, markTimes=TRUE,
                           markerSymbol=fa_icon_mark("plus"),
                           markerColor="black", ranges=FALSE) {
    # Check if there are groups
    if (is.null(surv$strata))
        group <- c("Series 1" = length(surv$time))
    else
        group <- surv$strata
    
    # Modify data according to functions (adapted from survival:::plot.survfit)
    if (is.character(fun)) {
        tfun <- switch(fun,
                       log = function(x) x,
                       event = function(x) 1 - x,
                       cumhaz = function(x) -log(x),
                       cloglog = function(x) log(-log(x)),
                       pct = function(x) x * 100,
                       logpct = function(x) 100 * x,
                       identity = function(x) x,
                       function(x) x)
    } else if (is.function(fun)) {
        tfun <- fun
    } else 
        tfun <- function(x) x
    
    firsty <- tfun(1)
    surv$surv <- tfun(surv$surv)
    if (ranges && !is.null(surv$upper)) {
        surv$upper <- tfun(surv$upper)
        surv$lower <- tfun(surv$lower)
    }
    
    # Data markers
    noMarker <- list(list(enabled=FALSE))
    marker <- ifelse(
        markTimes,
        list(list(fillColor=markerColor, symbol=markerSymbol, enabled=TRUE)),
        noMarker)
    
    # Prepare data
    mark <- ifelse(surv$n.censor == 1, 1, 0)
    data <- data.frame(x=surv$time, y=surv$surv, mark,
                       up=surv$upper, low=surv$lower,
                       group=rep(names(group), group), 
                       stringsAsFactors = FALSE)
    
    # Adjust Y axis range
    yValues <- data$y
    ymin <- ifelse(min(yValues) >= ymin, ymin, min(yValues))
    ymax <- ifelse(max(yValues) <= ymax, ymax, max(yValues))
    
    hc <- highchart() %>%
        hc_chart(zoomType="xy") %>%
        hc_tooltip(shared = TRUE) %>%
        hc_yAxis(min=ymin, max=ymax, 
                 title=list(text="Proportion of individuals")) %>%
        hc_xAxis(title=list(text="Time in days"))
    
    count <- 0
    for (name in names(group)) {
        df <- subset(data, group == name)
        
        # Add first value if there is no x=0 in the data
        first <- NULL
        if (!0 %in% df$x)
            first <- list(list(x=0, y=firsty, marker=noMarker))
        
        # Mark events
        ls <- list.parse3(df)
        if (markTimes) {
            ls <- lapply(ls, function(i)
                c(i, marker=ifelse(i$mark, marker, noMarker)))
        }
        
        hc <- hc %>% hc_add_series(
            data=c(first, ls), step="left", name=name, zIndex=1,
            color=JS("Highcharts.getOptions().colors[", count, "]"))
        
        if (ranges) {
            # Add interval range
            range <- lapply(ls, function(i) 
                setNames(i[c("x", "low", "up")], NULL))
            hc <- hc %>% hc_add_series(
                data=range, step="left", name="Ranges", type="arearange",
                zIndex=0, linkedTo=':previous', fillOpacity=0.3, lineWidth=0,
                color=JS("Highcharts.getOptions().colors[", count, "]"))
        }
        count <- count + 1
    }
    
    return(hc)
}

fit <- coxph(Surv(futime, fustat) ~ age, data = ovarian) 
surv <- survfit(fit, newdata=data.frame(age=c(20,60)))
plot(surv, xscale=365.25, xlab = "Years", ylab="Survival")
plotSurvCurves(surv, ranges=TRUE)
```

Let's check out interval ranges for more than one group (it looks crowded...):
```{r, eval=FALSE}
plotSurvCurves(aml.surv, ranges = TRUE)
```

This function was sent and accepted as a pull request to the R package
[Highcharter](http://jkunst.com/highcharter).

## References

- [Wikipedia](https://en.wikipedia.org/wiki/Survival_analysis#Introduction_to_survival_analysis)
- [Question: Survival Analysis Using Tcga Data](https://www.biostars.org/p/96209/)
- [Tutorial: Survival analysis of TCGA patients integrating gene expression (RNASeq) data](https://www.biostars.org/p/153013/)
- [Statistical Lifetime Models, Lecture 1 Notes](http://www.stats.ox.ac.uk/~mlunn/lecturenotes1.pdf)
- [What is a Cox model?](http://www.medicine.ox.ac.uk/bandolier/painres/download/whatis/cox_model.pdf)
- [Hazard Ratio in Clinical Trials](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC478551/pdf/1409-03.pdf)
- http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3932959/pdf/nihms549224.pdf
- http://www.sthda.com/english/wiki/principal-component-analysis-how-to-reveal-the-most-important-variables-in-your-data-r-software-and-data-mining